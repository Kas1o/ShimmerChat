@using Markdig
@using Markdig.Extensions.Tables
@using ShimmerChatLib
@using SharperLLM.Util

@inject IStringLocalizer<Message> l
@inject IJSRuntime JS
@inject IMessageDisplayService MessageDisplayService
@inject IKVDataService KVData


<div class="shimmer-message">
	<!-- #region 头部菜单 -->
	<div class="shimmer-message-head">
		<div>
			@sender 
			@(message.IsStreaming ? "(流式生成中...)" : "")
			@if (message.HasMultipleVersions)
			{
				<span class="version-indicator">(@(message.CurrentVersionIndex + 1)/@message.Versions.Count)</span>
			}
		</div>
		<div class="shimmer-message-head-action">
			@if (message.HasMultipleVersions)
			{
				<div class="version-navigation">
					<button class="version-btn" @onclick="() => NavigateToPreviousVersion()" disabled="@(message.CurrentVersionIndex <= 0)">
						&lt;
					</button>
					<button class="version-btn" @onclick="() => NavigateToNextVersion()" disabled="@(message.CurrentVersionIndex >= message.Versions.Count - 1)">
						&gt;
					</button>
				</div>
			}
			@if (message.sender == ShimmerChatLib.Sender.AI)
			{
				<div @onclick="RegenerateFromThisMessage" style="display: @(message.IsStreaming ? "none" : "block")">
					@l["BUTTON_REGENERATE"]
				</div>
			}
			<div @onclick="e => DeleteThisMessage()">
				@l["BUTTON_DELETE"]
			</div>
			<div @onclick="CopyContentToClipboard">
				@l["BUTTON_COPY"]
			</div>
			<div @onclick="EnterEditMode" style="display: @(message.IsStreaming ? "none" : "block")">
				@l["BUTTON_EDIT"]
			</div>
		</div>
	</div>
	<!-- #endregion -->



	<!-- #region 编辑器&常规内容 -->
	@if (isEditMode)
	{
		<div>
			<label>思考内容:</label>
			<textarea @bind="editThinking" rows="3" style="width:100%; margin-bottom: 10px;"></textarea>
			<label>消息内容:</label>
			<textarea @bind="editContent" rows="4" style="width:100%"></textarea>
			<!-- 这里有个长文本输入问题，Blazor SignalR 消息不允许过长的文本输入-->
			<button class="btn btn-success" @onclick="SaveEdit">@l["BUTTON_SAVE"]</button>
			<button class="btn" @onclick="CancelEdit">@l["BUTTON_CANCEL"]</button>
		</div>
	}
	else
	{
		<!-- #region 思维链展示 -->
		@if(!String.IsNullOrEmpty(CurrentMessageContent?.thinking))
		{
			<div class="shimmer-message-thinking">
				<details>
					<summary>
						思考……
					</summary>
					@DisplayThinking
				</details>
			</div>
		}
		<!-- #endregion -->
		
		@DisplayContent
		@if(message.IsStreaming)
		{
			<span class="shimmer-typing-indicator">▌</span>
		}
	}
	<!-- #endregion -->

	<!-- #region 工具调用 -->
	@if(CurrentMessageContent?.toolCalls != null)
	@if(CurrentMessageContent?.toolCalls.Count > 0)
	{
		<ToolCallMessage message="message" />
	}
	
	<!-- #endregion -->

</div>


@code {
	[Parameter]
	public Action Delete { get; set; } = null;

	[Parameter]
	public Action MakeDirty { get; set; } = null!; // Callback to make the parent component dirty

	[Parameter]
	public Action RegenerateFrom { get; set; } = null!; // Callback to regenerate from this message

	[Parameter]
	public ShimmerChatLib.Message message { get; set; } = null!; // The message object to display

	[Parameter]
	public string AgentName { get; set; } = "EmptyName";

	bool isEditMode = false;
	string editContent = string.Empty;
	string editThinking = string.Empty;

	// 获取当前版本的消息内容
	ChatMessage CurrentMessageContent => message.CurrentVersion;

	string stringContent => CurrentMessageContent?.Content ?? string.Empty; // The string content of the message

	MarkupString DisplayContent => MessageDisplayService.RenderMarkdown(stringContent);
	MarkupString DisplayThinking => MessageDisplayService.RenderMarkdown(CurrentMessageContent?.thinking ?? string.Empty);


	string imageContent => CurrentMessageContent?.ImageBase64 ?? string.Empty; // The base64 string for the image content, if any

	string sender => message.sender switch
	{
		ShimmerChatLib.Sender.User => KVData.Read("User", "username") ?? "User",
		ShimmerChatLib.Sender.AI => AgentName,
		ShimmerChatLib.Sender.ToolResult => l["ToolResult"],
		var other => other
	};

	// 当组件初始化时设置
	protected override void OnInitialized()
	{
		base.OnInitialized();
		// 订阅Message对象的事件
		SubscribeToMessageEvents();
	}

	// 当message参数变化时重新订阅
	protected override void OnParametersSet()
	{
		base.OnParametersSet();
		// 重新订阅Message对象的事件
		SubscribeToMessageEvents();
	}

	// 订阅Message对象的事件
	private void SubscribeToMessageEvents()
	{
		// 移除可能存在的旧订阅
		message.ContentChanged -= HandleContentChanged;
		message.StreamingStateChanged -= HandleStreamingStateChanged;
		message.VersionChanged -= HandleVersionChanged;

		// 添加新订阅
		message.ContentChanged += HandleContentChanged;
		message.StreamingStateChanged += HandleStreamingStateChanged;
		message.VersionChanged += HandleVersionChanged;
	}

	// 当内容变化时刷新UI
	private void HandleContentChanged(object? sender, EventArgs e)
	{
		// 通知Blazor重新渲染组件
		InvokeAsync(StateHasChanged);
	}

	// 当流式状态变化时刷新UI
	private void HandleStreamingStateChanged(object? sender, EventArgs e)
	{
		// 通知Blazor重新渲染组件
		InvokeAsync(StateHasChanged);
	}

	// 当版本变化时刷新UI
	private void HandleVersionChanged(object? sender, EventArgs e)
	{
		// 通知Blazor重新渲染组件
		InvokeAsync(StateHasChanged);
	}

	// 组件销毁时取消订阅，防止内存泄漏
	public void Dispose()
	{
		if (message != null)
		{
			message.ContentChanged -= HandleContentChanged;
			message.StreamingStateChanged -= HandleStreamingStateChanged;
			message.VersionChanged -= HandleVersionChanged;
		}
	}

	// 导航到上一个版本
	private void NavigateToPreviousVersion()
	{
		if (message.CurrentVersionIndex > 0)
		{
			message.CurrentVersionIndex--;
			MakeDirty?.Invoke();
		}
	}

	// 导航到下一个版本
	private void NavigateToNextVersion()
	{
		if (message.CurrentVersionIndex < message.Versions.Count - 1)
		{
			message.CurrentVersionIndex++;
			MakeDirty?.Invoke();
		}
	}

	// 渲染逻辑已迁移到IMessageDisplayService单例服务中
	// 之前每个Message组件都会创建一个新的MarkdownPipeline实例，这是不必要的资源消耗
	// 现在所有组件共享同一个服务实例，大幅减少了内存占用和初始化开销

	void DeleteThisMessage()
	{
		Delete();
	}

	void RegenerateFromThisMessage()
	{
		RegenerateFrom?.Invoke();
	}

	async Task CopyContentToClipboard()
	{
		await JS.InvokeVoidAsync("copyTextToClipboard", stringContent);
	}

	void EnterEditMode()
	{
		if (isEditMode || message.IsStreaming)
		{
			CancelEdit();
			return;
		}
		isEditMode = true;
		editContent = stringContent;
		editThinking = CurrentMessageContent?.thinking ?? string.Empty;
	}

	void SaveEdit()
	{
		if (CurrentMessageContent != null)
		{
			CurrentMessageContent.Content = editContent;
			CurrentMessageContent.thinking = editThinking;
		}
		isEditMode = false;
		MakeDirty?.Invoke();
	}

	void CancelEdit()
	{
		isEditMode = false;
	}
}
